// src/config/database.js
require('dotenv').config();

module.exports = {
  development: {
    username: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    host: process.env.DB_HOST,
    dialect: 'postgres',
    logging: false
  },
  test: {
    username: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME_TEST,
    host: process.env.DB_HOST,
    dialect: 'postgres',
    logging: false
  },
  production: {
    username: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    host: process.env.DB_HOST,
    dialect: 'postgres',
    logging: false,
    dialectOptions: {
      ssl: {
        require: true,
        rejectUnauthorized: false
      }
    }
  }
};

// src/models/index.js
const fs = require('fs');
const path = require('path');
const Sequelize = require('sequelize');
const process = require('process');
const basename = path.basename(__filename);
const env = process.env.NODE_ENV || 'development';
const config = require('../config/database.js')[env];
const db = {};

let sequelize;
if (config.use_env_variable) {
  sequelize = new Sequelize(process.env[config.use_env_variable], config);
} else {
  sequelize = new Sequelize(
    config.database,
    config.username,
    config.password,
    config
  );
}

fs.readdirSync(__dirname)
  .filter(file => {
    return (
      file.indexOf('.') !== 0 &&
      file !== basename &&
      file.slice(-3) === '.js' &&
      file.indexOf('.test.js') === -1
    );
  })
  .forEach(file => {
    const model = require(path.join(__dirname, file))(sequelize, Sequelize.DataTypes);
    db[model.name] = model;
  });

Object.keys(db).forEach(modelName => {
  if (db[modelName].associate) {
    db[modelName].associate(db);
  }
});

db.sequelize = sequelize;
db.Sequelize = Sequelize;

module.exports = db;

// src/models/schedule.model.js
const { Model } = require('sequelize');

module.exports = (sequelize, DataTypes) => {
  class Schedule extends Model {
    static associate(models) {
      // Define associations here
    }
  }

  Schedule.init({
    id: {
      type: DataTypes.UUID,
      defaultValue: DataTypes.UUIDV4,
      primaryKey: true
    },
    patientName: {
      type: DataTypes.STRING,
      allowNull: false
    },
    doctorName: {
      type: DataTypes.STRING,
      allowNull: false
    },
    date: {
      type: DataTypes.DATEONLY,
      allowNull: false
    },
    time: {
      type: DataTypes.TIME,
      allowNull: false
    },
    type: {
      type: DataTypes.ENUM('CONSULTATION', 'FOLLOW_UP', 'EXAMINATION'),
      defaultValue: 'CONSULTATION'
    },
    status: {
      type: DataTypes.ENUM('SCHEDULED', 'COMPLETED', 'CANCELLED'),
      defaultValue: 'SCHEDULED'
    },
    notes: {
      type: DataTypes.TEXT
    }
  }, {
    sequelize,
    modelName: 'Schedule',
    tableName: 'schedules',
    timestamps: true
  });

  return Schedule;
};

// src/migrations/20231216000000-create-schedules.js
module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.createTable('schedules', {
      id: {
        type: Sequelize.UUID,
        defaultValue: Sequelize.UUIDV4,
        primaryKey: true
      },
      patientName: {
        type: Sequelize.STRING,
        allowNull: false
      },
      doctorName: {
        type: Sequelize.STRING,
        allowNull: false
      },
      date: {
        type: Sequelize.DATEONLY,
        allowNull: false
      },
      time: {
        type: Sequelize.TIME,
        allowNull: false
      },
      type: {
        type: Sequelize.ENUM('CONSULTATION', 'FOLLOW_UP', 'EXAMINATION'),
        defaultValue: 'CONSULTATION'
      },
      status: {
        type: Sequelize.ENUM('SCHEDULED', 'COMPLETED', 'CANCELLED'),
        defaultValue: 'SCHEDULED'
      },
      notes: {
        type: Sequelize.TEXT
      },
      createdAt: {
        type: Sequelize.DATE,
        allowNull: false
      },
      updatedAt: {
        type: Sequelize.DATE,
        allowNull: false
      }
    });

    // Add indexes
    await queryInterface.addIndex('schedules', ['doctorName']);
    await queryInterface.addIndex('schedules', ['date']);
    await queryInterface.addIndex('schedules', ['status']);
  },

  down: async (queryInterface, Sequelize) => {
    await queryInterface.dropTable('schedules');
  }
};

// src/services/schedule.service.js
const { Schedule } = require('../models');
const { Op } = require('sequelize');

class ScheduleService {
  async createSchedule(scheduleData) {
    return await Schedule.create(scheduleData);
  }

  async getSchedules(filters = {}) {
    const whereClause = {};
    
    if (filters.doctorName) {
      whereClause.doctorName = filters.doctorName;
    }
    
    if (filters.startDate && filters.endDate) {
      whereClause.date = {
        [Op.between]: [filters.startDate, filters.endDate]
      };
    }
    
    if (filters.status) {
      whereClause.status = filters.status;
    }

    return await Schedule.findAll({
      where: whereClause,
      order: [['date', 'ASC'], ['time', 'ASC']]
    });
  }

  async updateSchedule(id, updateData) {
    const schedule = await Schedule.findByPk(id);
    if (!schedule) {
      return null;
    }
    return await schedule.update(updateData);
  }

  async deleteSchedule(id) {
    const schedule = await Schedule.findByPk(id);
    if (!schedule) {
      return null;
    }
    await schedule.destroy();
    return schedule;
  }

  async getSchedulesByDoctor(doctorName, startDate, endDate) {
    return await Schedule.findAll({
      where: {
        doctorName,
        date: {
          [Op.between]: [startDate, endDate]
        }
      },
      order: [['date', 'ASC'], ['time', 'ASC']]
    });
  }

  async checkAvailability(doctorName, date, time) {
    const existingSchedule = await Schedule.findOne({
      where: {
        doctorName,
        date,
        time,
        status: {
          [Op.not]: 'CANCELLED'
        }
      }
    });
    return !existingSchedule;
  }
}

module.exports = new ScheduleService();

// src/server.js
const express = require('express');
const cors = require('cors');
const dotenv = require('dotenv');
const { sequelize } = require('./models');
const scheduleRoutes = require('./routes/schedule.routes');

dotenv.config();

const app = express();
const PORT = process.env.PORT || 3001;

// Middleware
app.use(cors());
app.use(express.json());

// Routes
app.use('/api/schedules', scheduleRoutes);

// Database connection and sync
sequelize.authenticate()
  .then(() => {
    console.log('Connected to PostgreSQL database');
    return sequelize.sync(); // In production, remove the sync and use migrations
  })
  .catch(err => {
    console.error('Database connection error:', err);
  });

// Error handling middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({ message: 'Something went wrong!' });
});

app.listen(PORT, () => {
  console.log(`Schedule service running on port ${PORT}`);
});
